/* logic_i
 * Author: Szegedi GÃ¡bor D071PO
 * Creation date: 2018-06-29
 */
IMPLEMENTATION logic_i
REFINES logic

IMPORTS
    io.io

DEFINITIONS
    "constants.def"
    
CONCRETE_VARIABLES
    a_array, b_array, c_array, c_has_special, c_special_index, logic_status

INVARIANT
    logic_status : LOGIC_STATE
    & a_array : 0..arraySize - 1 --> minValue .. maxValue
    & b_array : 0..arraySize - 1 --> minValue .. maxValue
    & c_array : 0..arraySize - 1 --> INT
    
    & a_array = a_array
    & b_array = b_array
    & c_array = c_array
    
    & (logic_status = LOGIC_INITIALIZING => io.io_status = IO_INITIALIZING)
    & (logic_status = LOGIC_A_READ => io.io_status = IO_A_READ)
    & (logic_status = LOGIC_B_READ => io.io_status = IO_B_READ)
    & (logic_status = LOGIC_C_CALCULATED => io.io_status = IO_B_READ)
    & (logic_status = LOGIC_SPECIAL_SEARCH_DONE => io.io_status = IO_B_READ)
    & (logic_status = LOGIC_COMPLETED => io.io_status = IO_WRITTEN)

INITIALISATION
    logic_status := LOGIC_INITIALIZING;
    a_array := (0..arraySize - 1)*{minValue};
    b_array := (0..arraySize - 1)*{minValue};
    c_array := (0..arraySize - 1)*{minValue};
    c_has_special := FALSE;
    c_special_index := 0
 
OPERATIONS
    init =
    BEGIN
        logic_status := LOGIC_INITIALIZING;
        io.io_init;
        a_array := (0..arraySize - 1)*{minValue};
        b_array := (0..arraySize - 1)*{minValue};
        c_array := (0..arraySize - 1)*{minValue};
        c_has_special := FALSE;
        c_special_index := 0
    END;
    
    init_a =
    BEGIN
        a_array <-- io.read_a;
        logic_status := LOGIC_A_READ
    END;
    
    init_b =
    BEGIN
        b_array <-- io.read_b(a_array);
        logic_status := LOGIC_B_READ
    END;
    
    calculate =
    BEGIN
        VAR index, size IN
            index := 0;
            size := arraySize;
			WHILE index < size DO
			    c_array(index) := 19*a_array(index)-9*b_array(index)+4;
   		        index := index+1
			INVARIANT
			    index : 0 ..size
				& c_array : 0..arraySize - 1 --> INT
				& !i.(i : 0..arraySize - 1 => 19*a_array(i)-9*b_array(i)+4 : INT)
				& !i.(i : 0..index-1 => c_array(i) = 19*a_array(i)-9*b_array(i)+4)
			VARIANT
				size-index
			END
		END;
       logic_status := LOGIC_C_CALCULATED
    END;
    
   search =
   BEGIN
       VAR index, t_found, t_ind, tmp1, tmp2, size IN
           index := 0;
		   t_ind := 0;
           t_found := FALSE;
           tmp1 := 0;
           tmp2 := 0;
           size := arraySize;
           WHILE t_found = FALSE & index < size DO
               tmp1 := c_array(index);
               IF 0 <= tmp1 THEN
                   tmp2 := tmp1 mod 32;
                   IF tmp2 = 25 THEN
                       t_found := TRUE;
                       t_ind := index
                   ELSE
                       t_found := FALSE;
                       t_ind := 0
                   END
               	END;
               index := index + 1
           INVARIANT
               t_found : BOOL
               & index : 0..size
               & t_ind : 0..size-1
               & t_ind <= index
               & c_array : 0..arraySize - 1 --> INT
               & tmp1 : INT
               & tmp2 : NAT
               & (t_found = TRUE => (!i.(i : 0 .. t_ind-1 => (0 <= c_array(i) => not(c_array(i) mod 32 = 25))) & c_array(t_ind) mod 32 = 25))
               & (t_found = FALSE => !i.(i : 0..index-1 => (0 <= c_array(i) => not(c_array(i) mod 32 = 25))))
           VARIANT
               size-index
           END;
           c_has_special := t_found;
           c_special_index := t_ind
       END;
       logic_status := LOGIC_SPECIAL_SEARCH_DONE
   END;
    
    write_result =
    BEGIN
        io.write_result(c_array, c_has_special, c_special_index);
        logic_status := LOGIC_COMPLETED
    END

END